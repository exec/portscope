use std::net::{IpAddr, SocketAddr, UdpSocket};
use std::time::Duration;
use anyhow::Result;

use crate::scanner::results::PortStatus;

pub async fn udp_scan(target: IpAddr, port: u16, timeout_ms: u64) -> PortStatus {
    tokio::task::spawn_blocking(move || {
        match udp_probe(target, port, timeout_ms) {
            Ok(status) => status,
            Err(_) => PortStatus::Error,
        }
    }).await.unwrap_or(PortStatus::Error)
}

fn udp_probe(target: IpAddr, port: u16, timeout_ms: u64) -> Result<PortStatus> {
    let socket = UdpSocket::bind("0.0.0.0:0")?;
    socket.set_read_timeout(Some(Duration::from_millis(timeout_ms)))?;
    
    let addr = SocketAddr::new(target, port);
    
    let probe_data = get_service_probe(port);
    socket.send_to(&probe_data, addr)?;
    
    let mut buf = [0u8; 1024];
    match socket.recv_from(&mut buf) {
        Ok(_) => Ok(PortStatus::Open),
        Err(e) => {
            if e.kind() == std::io::ErrorKind::WouldBlock || 
               e.kind() == std::io::ErrorKind::TimedOut {
                Ok(PortStatus::Open)
            } else if e.kind() == std::io::ErrorKind::ConnectionRefused {
                Ok(PortStatus::Closed)
            } else {
                Ok(PortStatus::Filtered)
            }
        }
    }
}

fn get_service_probe(port: u16) -> Vec<u8> {
    match port {
        // DNS query for version.bind TXT
        53 => vec![
            0x12, 0x34, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x07, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x04, 0x62, 0x69, 0x6e,
            0x64, 0x00, 0x00, 0x10, 0x00, 0x03
        ],
        // NTP request
        123 => vec![
            0x1b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        ],
        // SNMP GetRequest for sysDescr
        161 => vec![
            0x30, 0x26, 0x02, 0x01, 0x00, 0x04, 0x06, 0x70, 0x75, 0x62, 0x6c, 0x69,
            0x63, 0xa0, 0x19, 0x02, 0x04, 0x00, 0x00, 0x00, 0x01, 0x02, 0x01, 0x00,
            0x02, 0x01, 0x00, 0x30, 0x0b, 0x30, 0x09, 0x06, 0x05, 0x2b, 0x06, 0x01,
            0x02, 0x01, 0x05, 0x00
        ],
        // DHCP Discover
        67 | 68 => vec![
            0x01, 0x01, 0x06, 0x00, 0x12, 0x34, 0x56, 0x78, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00
        ],
        // NetBIOS Name Service
        137 => vec![
            0x12, 0x34, 0x01, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x20, 0x43, 0x4b, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
            0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
            0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x00, 0x00, 0x21,
            0x00, 0x01
        ],
        // TFTP Read Request
        69 => b"\x00\x01tftp\x00netascii\x00".to_vec(),
        // SIP OPTIONS
        5060 => b"OPTIONS sip:test@example.com SIP/2.0\r\n\r\n".to_vec(),
        // Default UDP probe
        _ => vec![0x00, 0x01, 0x02, 0x03],
    }
}